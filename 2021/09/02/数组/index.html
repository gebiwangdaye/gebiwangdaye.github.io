<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>数组 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1、 基础用法1.1 声明数组语法格式 var variable_name [SIZE] variable_type 1.2 初始化数组 var balance &#x3D; [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}  如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度：var balance &#x3D; […]float32{1000.0">
<meta property="og:type" content="article">
<meta property="og:title" content="数组">
<meta property="og:url" content="http://example.com/2021/09/02/%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、 基础用法1.1 声明数组语法格式 var variable_name [SIZE] variable_type 1.2 初始化数组 var balance &#x3D; [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}  如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度：var balance &#x3D; […]float32{1000.0">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-09-02T15:38:04.000Z">
<meta property="article:modified_time" content="2021-09-02T15:38:04.340Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2021-09-02T15:38:04.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      数组
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1、 基础用法<br>1.1 声明数组<br>语法格式</p>
<p>var variable_name [SIZE] variable_type</p>
<p>1.2 初始化数组</p>
<p>var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</p>
<p> 如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度：<br>var balance = […]float32{1000.0, 2.0, 3.4, 7.0, 50.0}或balance := […]float32{1000.0, 2.0, 3.4, 7.0, 50.0}如果设置了数组的长度，我们还可以通过指定下标来初始化元素：<br>//  将索引为 1 和 3 的元素初始化balance := [5]float32{1:2.0,3:7.0}初始化数组中 {} 中的元素个数不能大于 [] 中的数字。<br>如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小。<br>2、原理分析<br>数组和切片是 Go 语言中常见的数据结构，很多刚刚解除 Go 的开发者往往会混淆这两个概念。数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 —— 切片，切片与数组有一些类似，但是它们的不同导致了使用上的巨大差别。下面主要从编译期以及运行时分析一下数组的底层实现原理。<br>2.1 概述<br>func NewArray(elem *Type, bound int64) *Type {<br>    if bound &lt; 0 {<br>        Fatalf(“NewArray: invalid bound %v”, bound)<br>    }<br>    t := New(TARRAY)<br>    t.Extra = &amp;Array{Elem: elem, Bound: bound}<br>    t.SetNotInHeap(elem.NotInHeap())<br>    return t<br>}编译期间的数组类型是由上述的  cmd/compile/internal/types.NewArray 函数生成的，该类型包含两个字段，分别是元素类型<br>Elem</p>
<p> 和数组的大小<br>Bound</p>
<p>，这两个字段共同构成了数组类型，而当前数组是否应该在堆栈中初始化也在编译期就确定了。<br>2.2 初始化<br>Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用<br>[…]T</p>
<p> 声明数组，Go 语言会在编译期间通过源代码推导数组的大小：<br>a := [3] int{1, 2, 3}<br>b := […] int{1, 2, 3}这两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导，下面我们来介绍编译器的推导过程。<br>上限推导<br>两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式<br>[10]T</p>
<p>，那么变量的类型在编译进行到类型检查阶段就会被提取出来，随后使用<br>cmd/compile/internal/types.NewArray</p>
<p>创建包含数组大小的<br>cmd/compile/internal/types.Array</p>
<p> 结构体。<br>当我们使用<br>[…]T</p>
<p> 的方式声明数组时，编译器会在的<br>cmd/compile/internal/gc.typecheckcomplit</p>
<p> 函数中对该数组的大小进行推导：<br>这个删减后的<br>cmd/compile/internal/gc.typecheckcomplit</p>
<p> 会调用<br>cmd/compile/internal/gc.typecheckarraylit</p>
<p> 通过遍历元素的方式来计算数组中元素的数量。<br>所以我们可以看出<br>[…]T{1, 2, 3}</p>
<p> 和<br>[3]T{1, 2, 3}</p>
<p> 在运行时是完全等价的，<br>[…]T</p>
<p> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。<br>语句转换<br>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的<br>cmd/compile/internal/gc.anylit</p>
<p> 函数中做两种不同的优化：</p>
<ol>
<li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li>
<li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；<br>func anylit(n *Node, var_ *Node, init *Nodes) {当数组的元素小于或者等于四个时，<br>cmd/compile/internal/gc.fixedlit</li>
</ol>
<p> 会负责在函数编译之前将<br>[3]{1, 2, 3}</p>
<p> 转换成更加原始的语句：<br>当数组中元素的个数小于或者等于四个并且<br>cmd/compile/internal/gc.fixedlit</p>
<p> 函数接收的<br>kind</p>
<p> 是<br>initKindLocalCode</p>
<p> 时，上述代码会将原有的初始化语句<br>[3]int{1, 2, 3}</p>
<p> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：<br>但是如果当前数组的元素大于四个，<br>cmd/compile/internal/gc.anylit</p>
<p> 会先获取一个唯一的<br>staticname</p>
<p>，然后调用<br>cmd/compile/internal/gc.fixedlit</p>
<p> 函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：<br>假设代码需要初始化<br>[5]int{1, 2, 3, 4, 5}</p>
<p>，那么我们可以将上述过程理解成以下的伪代码：<br>总结起来，在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。<br>2.3 访问和赋值<br>无论是在栈上还是静态存储区，数组在内存中都是一段连续的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生越界；而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，无论丢失了哪个信息，我们都无法知道这片连续的内存空间到底存储了什么数据。<br>数组访问越界是非常严重的错误，Go 语言中可以在编译期间的静态类型检查判断数组越界，<br>cmd/compile/internal/gc.typecheck1</p>
<p> 会验证访问数组的索引：<br>func typecheck1(n *Node, top int) (res *Node) {<br>    switch n.Op {<br>    case OINDEX:<br>        ok |= ctxExpr<br>        l := n.Left  // array<br>        r := n.Right // index<br>        switch n.Left.Type.Etype {<br>        case TSTRING, TARRAY, TSLICE:<br>            …<br>            if n.Right.Type != nil &amp;&amp; !n.Right.Type.IsInteger() {<br>                yyerror(“non-integer array index %v”, n.Right)<br>                break<br>            }<br>            if !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) {<br>                x := n.Right.Int64Val()<br>                if x &lt; 0 {<br>                    yyerror(“invalid %s index %v (index must be non-negative)”, why, n.Right)<br>                } else if t.IsArray() &amp;&amp; x &gt;= t.NumElem() {<br>                    yyerror(“invalid array index %v (out of bounds for %d-element array)”, n.Right, t.NumElem())<br>                } else if Isconst(n.Left, CTSTR) &amp;&amp; x &gt;= int64(len(n.Left.StringVal())) {<br>                    yyerror(“invalid string index %v (out of bounds for %d-byte string)”, n.Right, len(n.Left.StringVal()))<br>                } else if n.Right.Val().U.(*Mpint).Cmp(maxintval[TINT]) &gt; 0 {<br>                    yyerror(“invalid %s index %v (index too large)”, why, n.Right)<br>                }<br>            }<br>        }<br>    …<br>    }<br>}<br>​访问数组的索引是非整数时，报错 “non-integer array index %v”；<br>访问数组的索引是负数时，报错 “invalid array index %v (index must be non-negative)”；<br>访问数组的索引越界时，报错 “invalid array index %v (out of bounds for %d-element array)”；数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组；但是如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言运行时阻止不合法的访问：<br>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的<br>runtime.panicIndex</p>
<p> 和<br>runtime.goPanicIndex</p>
<p> 触发程序的运行时错误并导致崩溃退出：<br>JMP     398<br>MOVL    $3, CX<br>CALL    runtime.panicIndex(SB)<br>XCHGL   AX, AX<br>​TEXT runtime·panicIndex(SB),NOSPLIT,$0-16<br>    MOVV    R1, x+0(FP)<br>    MOVV    R2, y+8(FP)<br>    JMP runtime·goPanicIndex(SB)func goPanicIndex(x int, y int) {<br>    panicCheck1(getcallerpc(), “index out of range”)<br>    panic(boundsError{x: int64(x), signed: true, y: y, code: boundsIndex})<br>}当数组的访问操作<br>OINDEX</p>
<p> 成功通过编译器的检查后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 ssa.html 文件：</p>
<p>start</p>
<p> 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分是<br>elem := arr[i]</p>
<p> 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令<br>IsInBounds</p>
<p> 以及当条件不满足时触发程序崩溃的<br>PanicBounds</p>
<p> 指令：<br>编译器会将<br>PanicBounds</p>
<p> 指令转换成上面提到的<br>runtime.panicIndex</p>
<p> 函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标、利用<br>PtrIndex</p>
<p> 计算出目标元素的地址，最后使用<br>Load</p>
<p> 操作将指针中的元素加载到内存中。<br>    当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入<br>PanicBounds</p>
<p> 指令交给运行时进行判断，在使用字面量整数访问数组下标时会生成非常简单的中间代码，当我们将上述代码中的<br>arr[i]</p>
<p> 改成<br>arr[2]</p>
<p> 时，就会得到如下所示的代码：<br>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界。<br>数组的赋值和更新操作<br>a[i] = 2</p>
<p> 也会生成 SSA 生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容，这些赋值语句会被转换成如下所示的 SSA 代码：<br>赋值的过程中会先确定目标数组的地址，再通过<br>PtrIndex</p>
<p> 获取目标元素的地址，最后使用<br>Store</p>
<p> 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出 上述数组寻址和赋值都是在编译阶段完成的，没有运行时的参与。<br>数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存，在中间代码生成期间，编译器还会插入运行时方法<br>runtime.panicIndex</p>
<p> 调用防止发生越界错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/02/%E6%95%B0%E7%BB%84/" data-id="ckt33n5ve0001torc3t3gbwd2" data-title="数组" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/09/01/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/02/%E6%95%B0%E7%BB%84/">数组</a>
          </li>
        
          <li>
            <a href="/2021/09/01/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>